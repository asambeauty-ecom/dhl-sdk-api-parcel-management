<?php
/**
 * PreferredNeighbourOrder
 *
 * PHP version 5
 *
 * @category Class
 * @package  Dhl\ParcelManagement
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * DHL Parcel Management API
 *
 * OpenAPI spec version: 1.3.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Dhl\ParcelManagement\Model;

use \ArrayAccess;
use \Dhl\ParcelManagement\ObjectSerializer;

/**
 * PreferredNeighbourOrder Class Doc Comment
 *
 * @category Class
 * @description Orders for nominating a neighbour that is eligible to receive the shipment, if the original recipient is absent. Neighbours are supposed to reside in proximity to the original recipient, i.e., in another apartment in the same house, on the opposite street side, or next to the house of the original recipient.
 * @package  Dhl\ParcelManagement
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PreferredNeighbourOrder implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'PreferredNeighbourOrder';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'salutation' => 'string',
        'firstName' => 'string',
        'lastName' => 'string',
        'street' => 'string',
        'houseNumber' => 'string',
        'addressAddition' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'salutation' => null,
        'firstName' => null,
        'lastName' => null,
        'street' => null,
        'houseNumber' => null,
        'addressAddition' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'salutation' => 'salutation',
        'firstName' => 'firstName',
        'lastName' => 'lastName',
        'street' => 'street',
        'houseNumber' => 'houseNumber',
        'addressAddition' => 'addressAddition'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'salutation' => 'setSalutation',
        'firstName' => 'setFirstName',
        'lastName' => 'setLastName',
        'street' => 'setStreet',
        'houseNumber' => 'setHouseNumber',
        'addressAddition' => 'setAddressAddition'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'salutation' => 'getSalutation',
        'firstName' => 'getFirstName',
        'lastName' => 'getLastName',
        'street' => 'getStreet',
        'houseNumber' => 'getHouseNumber',
        'addressAddition' => 'getAddressAddition'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const SALUTATION_HERR = 'Herr';
    const SALUTATION_FRAU = 'Frau';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSalutationAllowableValues()
    {
        return [
            self::SALUTATION_HERR,
            self::SALUTATION_FRAU,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['salutation'] = isset($data['salutation']) ? $data['salutation'] : null;
        $this->container['firstName'] = isset($data['firstName']) ? $data['firstName'] : null;
        $this->container['lastName'] = isset($data['lastName']) ? $data['lastName'] : null;
        $this->container['street'] = isset($data['street']) ? $data['street'] : null;
        $this->container['houseNumber'] = isset($data['houseNumber']) ? $data['houseNumber'] : null;
        $this->container['addressAddition'] = isset($data['addressAddition']) ? $data['addressAddition'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['salutation'] === null) {
            $invalidProperties[] = "'salutation' can't be null";
        }
        $allowedValues = $this->getSalutationAllowableValues();
        if (!is_null($this->container['salutation']) && !in_array($this->container['salutation'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'salutation', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['firstName'] === null) {
            $invalidProperties[] = "'firstName' can't be null";
        }
        if (!preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $this->container['firstName'])) {
            $invalidProperties[] = "invalid value for 'firstName', must be conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.";
        }

        if ($this->container['lastName'] === null) {
            $invalidProperties[] = "'lastName' can't be null";
        }
        if (!preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $this->container['lastName'])) {
            $invalidProperties[] = "invalid value for 'lastName', must be conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.";
        }

        if ($this->container['street'] === null) {
            $invalidProperties[] = "'street' can't be null";
        }
        if (!preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $this->container['street'])) {
            $invalidProperties[] = "invalid value for 'street', must be conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.";
        }

        if ($this->container['houseNumber'] === null) {
            $invalidProperties[] = "'houseNumber' can't be null";
        }
        if (!preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $this->container['houseNumber'])) {
            $invalidProperties[] = "invalid value for 'houseNumber', must be conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.";
        }

        if (!is_null($this->container['addressAddition']) && !preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $this->container['addressAddition'])) {
            $invalidProperties[] = "invalid value for 'addressAddition', must be conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.";
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets salutation
     *
     * @return string
     */
    public function getSalutation()
    {
        return $this->container['salutation'];
    }

    /**
     * Sets salutation
     *
     * @param string $salutation The salutation for the neighbour.
     *
     * @return $this
     */
    public function setSalutation($salutation)
    {
        $allowedValues = $this->getSalutationAllowableValues();
        if (!in_array($salutation, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'salutation', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['salutation'] = $salutation;

        return $this;
    }

    /**
     * Gets firstName
     *
     * @return string
     */
    public function getFirstName()
    {
        return $this->container['firstName'];
    }

    /**
     * Sets firstName
     *
     * @param string $firstName The first name of the neighbour
     *
     * @return $this
     */
    public function setFirstName($firstName)
    {

        if ((!preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $firstName))) {
            throw new \InvalidArgumentException("invalid value for $firstName when calling PreferredNeighbourOrder., must conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.");
        }

        $this->container['firstName'] = $firstName;

        return $this;
    }

    /**
     * Gets lastName
     *
     * @return string
     */
    public function getLastName()
    {
        return $this->container['lastName'];
    }

    /**
     * Sets lastName
     *
     * @param string $lastName The last name of the neighbour
     *
     * @return $this
     */
    public function setLastName($lastName)
    {

        if ((!preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $lastName))) {
            throw new \InvalidArgumentException("invalid value for $lastName when calling PreferredNeighbourOrder., must conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.");
        }

        $this->container['lastName'] = $lastName;

        return $this;
    }

    /**
     * Gets street
     *
     * @return string
     */
    public function getStreet()
    {
        return $this->container['street'];
    }

    /**
     * Sets street
     *
     * @param string $street A street name of the neighbour's location. The `street` name of the preferred neighbour  might differ from the original recipient address just in rare cases, where, e.g., the original  recipient an the neighbour reside at an intersection.
     *
     * @return $this
     */
    public function setStreet($street)
    {

        if ((!preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $street))) {
            throw new \InvalidArgumentException("invalid value for $street when calling PreferredNeighbourOrder., must conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.");
        }

        $this->container['street'] = $street;

        return $this;
    }

    /**
     * Gets houseNumber
     *
     * @return string
     */
    public function getHouseNumber()
    {
        return $this->container['houseNumber'];
    }

    /**
     * Sets houseNumber
     *
     * @param string $houseNumber The house number of the neighbour's house.
     *
     * @return $this
     */
    public function setHouseNumber($houseNumber)
    {

        if ((!preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $houseNumber))) {
            throw new \InvalidArgumentException("invalid value for $houseNumber when calling PreferredNeighbourOrder., must conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.");
        }

        $this->container['houseNumber'] = $houseNumber;

        return $this;
    }

    /**
     * Gets addressAddition
     *
     * @return string
     */
    public function getAddressAddition()
    {
        return $this->container['addressAddition'];
    }

    /**
     * Sets addressAddition
     *
     * @param string $addressAddition Additional optional information about the neighbour's address, e.g., his or her apartment number.
     *
     * @return $this
     */
    public function setAddressAddition($addressAddition)
    {

        if (!is_null($addressAddition) && (!preg_match("/[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/", $addressAddition))) {
            throw new \InvalidArgumentException("invalid value for $addressAddition when calling PreferredNeighbourOrder., must conform to the pattern /[a-z,A-Z,0-9,Ä,Ü,Ö,ä,ü,ö,ß,\\s,\\,,\\.,\\(,\\),\\!,\\-,\/]*$/.");
        }

        $this->container['addressAddition'] = $addressAddition;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


